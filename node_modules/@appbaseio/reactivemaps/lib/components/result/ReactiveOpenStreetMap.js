'use strict';

exports.__esModule = true;

var _emotion = require('emotion');

var _ReactiveOpenStreetMa;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _types = require('@appbaseio/reactivecore/lib/utils/types');

var _types2 = _interopRequireDefault(_types);

var _MapPin = require('./addons/styles/MapPin');

var _ReactiveMap = require('./ReactiveMap');

var _ReactiveMap2 = _interopRequireDefault(_ReactiveMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OpenStreetMap = void 0;
var OpenStreetLayer = void 0;
var OpenStreetMaker = void 0;
var OpenStreetPopup = void 0;
var Icon = void 0;
var DivIcon = void 0;

var ReactiveOpenStreetMap = function (_Component) {
	_inherits(ReactiveOpenStreetMap, _Component);

	function ReactiveOpenStreetMap() {
		var _temp, _this, _ret;

		_classCallCheck(this, ReactiveOpenStreetMap);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.getMarkers = function (_ref) {
			var showMarkers = _ref.showMarkers,
			    renderData = _ref.renderData,
			    defaultPin = _ref.defaultPin,
			    onPopoverClick = _ref.onPopoverClick,
			    resultsToRender = _ref.resultsToRender,
			    getPosition = _ref.getPosition;

			if (showMarkers) {
				var markers = resultsToRender.map(function (item) {
					var position = getPosition(item);
					var openStreetMarkerProps = {
						riseOnHover: true
					};

					var openStreetPopupPorops = {
						css: {
							'.leaflet-popup-content-wrapper': {
								borderRadius: '3px !important'
							}
						}
					};

					if (renderData) {
						var data = renderData(item);

						if ('label' in data) {
							openStreetMarkerProps.icon = new DivIcon({
								html: _server2.default.renderToStaticMarkup(_react2.default.createElement(
									'div',
									{ className: _MapPin.mapPinWrapper },
									_react2.default.createElement(
										_MapPin.MapPin,
										{
											className: (0, _emotion.css)({ height: 'auto' })
										},
										data.label
									),
									_react2.default.createElement('div', {
										className: (0, _emotion.css)({
											position: 'absolute',
											left: 0,
											width: 0,
											height: 0,
											borderTop: '12px solid white',
											borderRight: '12px solid transparent',
											boxShadow: '0 2px 4px 0 rgba(0,0,0,0.15)'
										})
									}),
									onPopoverClick ? _react2.default.createElement(
										OpenStreetPopup,
										openStreetPopupPorops,
										onPopoverClick(item)
									) : null
								))
							});
							return _react2.default.createElement(
								OpenStreetMaker,
								_extends({
									key: item._id,
									position: [position.lat, position.lng]
								}, openStreetMarkerProps),
								onPopoverClick ? _react2.default.createElement(
									OpenStreetPopup,
									openStreetPopupPorops,
									onPopoverClick(item)
								) : null
							);
						} else if ('icon' in data) {
							openStreetMarkerProps.icon = new Icon({
								iconUrl: data.icon
							});
							return _react2.default.createElement(
								OpenStreetMaker,
								_extends({
									key: item._id,
									position: [position.lat, position.lng]
								}, openStreetMarkerProps),
								onPopoverClick ? _react2.default.createElement(
									OpenStreetPopup,
									openStreetPopupPorops,
									onPopoverClick(item)
								) : null
							);
						}
						openStreetMarkerProps.icon = new DivIcon({
							html: _server2.default.renderToStaticMarkup(data.custom)
						});
						return _react2.default.createElement(
							OpenStreetMaker,
							_extends({
								key: item._id,
								position: [position.lat, position.lng]
							}, openStreetMarkerProps),
							onPopoverClick ? _react2.default.createElement(
								OpenStreetPopup,
								openStreetPopupPorops,
								onPopoverClick(item)
							) : null
						);
					} else if (defaultPin) {
						openStreetMarkerProps.icon = new Icon({
							iconUrl: defaultPin
						});
					}
					return _react2.default.createElement(
						OpenStreetMaker,
						_extends({
							key: item._id,
							position: [position.lat, position.lng]
						}, openStreetMarkerProps),
						onPopoverClick ? _react2.default.createElement(
							OpenStreetPopup,
							openStreetPopupPorops,
							onPopoverClick(item)
						) : null
					);
				});

				return markers;
			}
			return null;
		}, _this.renderMap = function (params) {
			// we check for `OpenStreetMap` here instead of `window`
			// because leaflet and react-leaflet are incompatible with SSR setup
			// hence the leaflet modules are imported on mount and the component
			// is force-rendered to avail the map module
			if (typeof OpenStreetMap === 'undefined') return null;
			var markers = _this.getMarkers(params);

			var style = {
				width: '100%',
				height: '100%',
				position: 'relative'
			};

			return _react2.default.createElement(
				OpenStreetMap,
				{
					style: style,
					zoom: params.zoom,
					center: [params.center.lat, params.center.lng],
					className: (0, _emotion.css)({
						'.leaflet-div-icon': {
							width: 'auto !important',
							border: 0
						},
						'.leaflet-popup-content-wrapper': {
							borderRadius: '3px !important'
						}
					}),

					touchZoom: true,
					onDragend: function onDragend(obj) {
						params.handleOpenStreetOnDragEnd(obj.target.getBounds());
					}
				},
				_react2.default.createElement(OpenStreetLayer, {
					url: _this.props.tileServer || 'https://{s}.tile.osm.org/{z}/{x}/{y}.png'
				}),
				markers,
				_this.props.showMarkers && _this.props.markers,
				params.renderSearchAsMove()
			);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	ReactiveOpenStreetMap.prototype.componentDidMount = function componentDidMount() {
		/* eslint-disable */
		OpenStreetMap = require('react-leaflet').Map;
		OpenStreetLayer = require('react-leaflet').TileLayer;
		OpenStreetMaker = require('react-leaflet').Marker;
		OpenStreetPopup = require('react-leaflet').Popup;
		Icon = require('leaflet').Icon;
		DivIcon = require('leaflet').DivIcon;
		this.forceUpdate();
	};

	ReactiveOpenStreetMap.prototype.render = function render() {
		return _react2.default.createElement(_ReactiveMap2.default, _extends({}, this.props, { renderMap: this.renderMap }));
	};

	return ReactiveOpenStreetMap;
}(_react.Component);

ReactiveOpenStreetMap.propTypes = (_ReactiveOpenStreetMa = {
	autoCenter: _types2.default.bool,
	autoClosePopover: _types2.default.bool,
	center: _types2.default.location,
	className: _types2.default.string,
	componentId: _types2.default.stringRequired,
	dataField: _types2.default.stringRequired,
	defaultCenter: _types2.default.location,
	defaultZoom: _types2.default.number,
	defaultRadius: _types2.default.number,
	defaultPin: _types2.default.string,
	innerClass: _types2.default.style,
	markers: _types2.default.children,
	showMarkers: _types2.default.bool,
	tileServer: _types2.default.string,
	title: _types2.default.string,
	onError: _types2.default.func,
	onPopoverClick: _types2.default.func,
	renderError: _types2.default.title,
	react: _types2.default.react,
	renderData: _types2.default.func,
	renderAllData: _types2.default.func,
	size: _types2.default.number,
	sortBy: _types2.default.sortBy,
	stream: _types2.default.bool,
	streamAutoCenter: _types2.default.bool
}, _ReactiveOpenStreetMa['showMarkers'] = _types2.default.bool, _ReactiveOpenStreetMa.style = _types2.default.style, _ReactiveOpenStreetMa.unit = _types2.default.string, _ReactiveOpenStreetMa);

ReactiveOpenStreetMap.defaultProps = {
	size: 10,
	style: {},
	className: null,
	pages: 5,
	pagination: false,
	autoCenter: false,
	streamAutoCenter: false,
	defaultZoom: 8,
	mapProps: {},
	markerProps: {},
	markers: null,
	showMapStyles: false,
	showSearchAsMove: true,
	searchAsMove: false,
	showMarkers: true,
	showMarkerClusters: true,
	unit: 'mi',
	defaultRadius: 100
};

exports.default = ReactiveOpenStreetMap;